program chll
  
  use iso_fortran_env
  implicit none
  
  integer(int64) :: ni,nj,nk,n3
  real(real64) :: kbt = 0.05d0
  integer(int64) :: nsteps = 1000
  real(real64),allocatable :: nx(:,:,:),ny(:,:,:),nz(:,:,:)
  integer(int64),allocatable :: s(:,:,:) ! chirality
  integer(int64),allocatable :: sl1(:),sl2(:) ! sublattices corresponding to odds(1) and evens(2)
  integer(int64),allocatable :: naccept(:,:,:),nflip(:,:,:),dope(:,:,:)
  real(real64) :: d = 0.01d0 ! size of spin rotation perturbation
  real(real64) :: KK = 1.d0 !
  real(real64) :: rho=0.0d0 ! density of chiral dopant
  real(real64),allocatable :: rhoz(:) !measuring density of chiral in each z-slice
  real(real64) :: cosphi,sinphi,costh,sinth,phi,pi,twopi
  real(real64) :: faccept,e_excess,paccept,total_energy
  integer(int64) :: nsub,nsub1,nsub2,index
  integer(int64) :: i,j,k,istep,itry

  real(real64) :: scale,x1,x2,z1,z2 ! for outpu

  ni = 32
  nj = 32
  nk = 32
  n3 = ni*nj*nk
  pi = 4.0d0*datan(1.0d0)
  twopi = 2.0d0*pi
  nsub = ni*nj*nk/2

  ! sublattice note: initialize 1 list/sublattic, containing 1d index that maps to 3d (i,j,k)
  ! do concurrent(i=1:length(sublattic))
  !  i,j,k = de_index(sublattice(i))
  ! enddo
  
  allocate(nx(ni,nj,nk))
  allocate(ny(ni,nj,nk))
  allocate(nz(ni,nj,nk))
  allocate(s(ni,nj,nk))
  allocate(dope(ni,nj,nk))
  allocate(naccept(ni,nj,nk))
  allocate(nflip(ni,nj,nk))
  allocate(sl1(nsub))
  allocate(sl2(nsub))

  ! setting up initial random state
  do i = 1,ni
     do j = 1,nj
        do k = 1,nk
           s(i,j,k) = 1
           if (rand().le.0.5d0) then
              s(i,j,k) = -1
           endif
           dope(i,j,k) = 0
           costh = 2.d0*(rand()-0.5)
           sinth = dsqrt(1.d0-costh*costh)
           phi = rand()*twopi
           cosphi = dcos(phi)
           sinphi = dsin(phi)
           nx(i,j,k) = sinth*cosphi
           ny(i,j,k) = sinth*sinphi
           nz(i,j,k) = costh
        enddo
     enddo
  enddo

  ! create list of site indices for each sublattice, sub1, sub2
  nsub1 = 0
  nsub2 = 0
  do k = 1,nk
     do j = 1,nj
        do i = 1,ni
           index = i+(j-1)*ni + (k-1)*(ni*nj)
           if (mod(i+j+k,2).ne.0) then
              nsub1 = nsub1+1
              sl1(nsub1) = index
           else
              nsub2 = nsub2 + 1
              sl2(nsub2) = index
           endif
        enddo
     enddo
  enddo
  
  
  do istep = 1,nsteps
     naccept(:,:,:) = 0
     nflip(:,:,:) = 0
     do itry = 1,n3
     !do each sublattice
     !   do concurrent(i=1:ni:2,j=1:nj,
        ! monte-carlo for switching director
        ! temporary
        i = 1+floor(rand()*ni)
        j = 1+floor(rand()*nj)
        k = 1+floor(rand()*nk)
        call evolve_director(i,j,k,nx,ny,nz,s,naccept,kbt,KK,d)
        i = 1+floor(rand()*ni)
        j = 1+floor(rand()*nj)
        k = 1+floor(rand()*nk)
        call evolve_chirality(i,j,k,nx,ny,nz,s,nflip,kbt,KK)
     enddo ! end sublattice calc
     
     paccept = float(sum(naccept))/float(n3) ! % of accepted director rotation
     if (paccept.lt.0.4d0) then
        d = d*0.995
     elseif (paccept.gt.0.6d0) then
        d = d/0.995
     endif
     faccept = float(sum(nflip))/float(n3) 
     if (mod(istep,50).eq.0) then
        ! calculate total energy
        total_energy = etot(nx,ny,nz,s,KK,ni,nj,nk)
        e_excess = sum(float(s))/float(ni*nj*nk)
        print*,istep,total_energy,e_excess,paccept,faccept,d
        !print*,istep,total_energy,e_excess,sum(naccept),sum(nflip)
     ! calculate enantiomeric excess
     endif
  enddo

  open(unit=11,file='LLMC-configa.dat',status='unknown')
  open(unit=12,file='LLMC-configb.dat',status='unknown')

  scale = 0.4
  do i = 1,ni
     j = nj/2
     do k = 1,nk
        x1 = i-scale*nx(i,j,k)
        x2 = i+scale*nx(i,j,k)
        z1 = k-scale*nz(i,j,k)
        z2 = k+scale*nz(i,j,k)
        if (s(i,j,k).eq.1) then
           write(11,*) x1,z1
           write(11,*) x2,z2
           write(11,*)
        else
           write(12,*) x1,z1
           write(12,*) x2,z2
           write(12,*)
        endif
     enddo
  enddo
  close(unit=11)
  close(unit=12)

  deallocate(nx,ny,nz,nflip,naccept,s,dope)
  
contains

  subroutine evolve_director(i,j,k,nx,ny,nz,s,naccept,kbt,KK,d)
    implicit none
    integer(int64),intent(in) :: i,j,k
    real(real64), intent(in) :: kbt,KK
    real(real64),intent(in out),dimension(:,:,:) :: nx
    real(real64),intent(in out),dimension(:,:,:) :: ny
    real(real64),intent(in out),dimension(:,:,:) :: nz
    real(real64),intent(in out) :: d
    integer(int64), intent(in out) :: s(:,:,:),naccept(:,:,:)
    integer(int64) :: ip1,im1,jp1,jm1,kp1,km1
    real(real64) :: nnx,nny,nnz,eold,enew,ux,uy,uz,rsq,vx,vy,vz,phi,dcosphi,dsinphi,xxnew,yynew,zznew
    
    ip1 = i+1 !mod(i,ni) + 1
    im1 = i-1 !mod(i-2+ni,ni)+1
    jp1 = j+1 !mod(j,nj)+1
    jm1 = j-1 !mod(j-2+ni,ni)+1
    kp1 = k + 1
    km1 = k - 1

    ! store the current spin and set energy to zero
    nnx = nx(i,j,k)
    nny = ny(i,j,k)
    nnz = nz(i,j,k)
    eold = energy(nx,ny,nz,nnx,nny,nnz,s(i,j,k),s,KK,i,j,k,ip1,im1,jp1,jm1,kp1,km1,ni,nj,nk)
    ! rotate the director at site i,j,k to get trial director (stored in nnx,nny,nnz)
    if (dabs(nnz).gt.0.999d0) then
       phi = rand()*8.0d0*datan(1.0d0)
       xxnew = nnx+d*dcos(phi)
       yynew = nny+d*dsin(phi)
       zznew = nnz
       rsq = dsqrt(xxnew*xxnew+yynew*yynew+zznew*zznew)
       nnx = xxnew/rsq
       nny = yynew/rsq
       nnz = zznew/rsq
    else
       ux = -nny
       uy = nnx
       uz = 0.0d0
       rsq = dsqrt(ux*ux+uy*uy)
       ux = ux/rsq
       uy = uy/rsq
       uz = uz/rsq
       vx = -nnz*nnx
       vy = -nnz*nny
       vz = nnx*nnx+nny*nny
       rsq = dsqrt(vx*vx+vy*vy+vz*vz)
       vx = vx/rsq
       vy = vy/rsq
       vz = vz/rsq
       phi = rand()*8.0d0*datan(1.0d0)
       dcosphi = d*dcos(phi)
       dsinphi = d*dsin(phi)
       nnx = nnx+dcosphi*ux + dsinphi*vx
       nny = nny+dcosphi*uy + dsinphi*vy
       nnz = nnz+dcosphi*uz + dsinphi*vz
       rsq = dsqrt(nnx*nnx+nny*nny+nnz*nnz)
       nnx = nnx/rsq
       nny = nny/rsq
       nnz = nnz/rsq
    endif
    ! calculate enew w/ trial spin
    enew = energy(nx,ny,nz,nnx,nny,nnz,s(i,j,k),s,KK,i,j,k,ip1,im1,jp1,jm1,kp1,km1,ni,nj,nk)
    !print*,i,j,k,eold,enew,enew.lt.eold
    ! metropolis algorithm
    if (enew.lt.eold) then
       nx(i,j,k) = nnx
       ny(i,j,k) = nny
       nz(i,j,k) = nnz
       naccept(i,j,k) = naccept(i,j,k) + 1
     else
        if (rand().le.dexp(-(enew-eold)/kbt)) then
          nx(i,j,k) = nnx
          ny(i,j,k) = nny
          nz(i,j,k) = nnz
          naccept(i,j,k) = naccept(i,j,k) + 1
        endif
     endif
     end subroutine evolve_director

     subroutine evolve_chirality(i,j,k,nx,ny,nz,s,nflip,kbt,KK)
           implicit none
           integer(int64),intent(in) :: i,j,k
           real(real64), intent(in out) :: kbt,KK
           real(real64),intent(in out),dimension(:,:,:) :: nx
           real(real64),intent(in out),dimension(:,:,:) :: ny
           real(real64),intent(in out),dimension(:,:,:) :: nz
           integer(int64), intent(in out) :: s(:,:,:),nflip(:,:,:)
           real(real64) :: nnx,nny,nnz,eold,enew,old
           integer(int64):: snew,ip1,im1,jp1,jm1,kp1,km1
           ! monte-carlo for switching chirality
               ip1 = i+1 !mod(i,ni) + 1
               im1 = i-1 !mod(i-2+ni,ni)+1
               jp1 = j+1 !mod(j,nj)+1
               jm1 = j-1 !mod(j-2+ni,ni)+1
               kp1 = k + 1
               km1 = k - 1
        ! calculate eold
        nnx = nx(i,j,k)
        nny = ny(i,j,k)
        nnz = nz(i,j,k)
        eold = energy(nx,ny,nz,nnx,nny,nnz,s(i,j,k),s,KK,i,j,k,ip1,im1,jp1,jm1,kp1,km1,ni,nj,nk)
        ! switch chirality and calculate enew
        snew = -s(i,j,k)
        enew = energy(nx,ny,nz,nnx,nny,nnz,snew,s,KK,i,j,k,ip1,im1,jp1,jm1,kp1,km1,ni,nj,nk)
        ! metropolis
        if (enew.lt.eold) then
           s(i,j,k) = snew
           nflip(i,j,k) = nflip(i,j,k) + 1
        else
           if (rand().le.dexp(-(enew-eold)/kbt)) then
              s(i,j,k) = snew
              nflip(i,j,k) = nflip(i,j,k) + 1
           endif
        endif
        return
  end subroutine evolve_chirality
  
  real function energy(nx,ny,nz,nnx,nny,nnz,snew,sold,KK,i,j,k,ip1,im1,jp1,jm1,kp1,km1,ni,nj,nk)
    implicit none
    integer(int64),intent(in) :: i,j,k,ip1,im1,jp1,jm1,kp1,km1,snew,sold(:,:,:),ni,nj,nk
    real(real64),intent(in) :: nx(:,:,:),ny(:,:,:),nz(:,:,:),nnx,nny,nnz,KK
    real(real64) :: dott,crossx,crossy,crossz,sfac,etmp
    etmp = 0.0d0
    ! ip1
    if (ip1 .le. ni) then
       dott = nnx*nx(ip1,j,k) + nny*ny(ip1,j,k) + nnz*nz(ip1,j,k)
       crossx = nny*nz(ip1,j,k) - nnz*ny(ip1,j,k)
       sfac = 0.5d0*(snew+sold(ip1,j,k))
       etmp = etmp + (1.0d0-dott*dott)-KK*dott*crossx*sfac
    endif
    ! im1
    if (im1 .ge. 1) then
       dott = nnx*nx(im1,j,k) + nny*ny(im1,j,k) + nnz*nz(im1,j,k)
       crossx = nny*nz(im1,j,k) - nnz*ny(im1,j,k)
       sfac = 0.5d0*(snew+sold(im1,j,k))
       etmp = etmp + (1.0d0-dott*dott)+KK*dott*crossx*sfac
    endif
    ! jp1
    if (jp1 .le. nj) then
       dott = nnx*nx(i,jp1,k) + nny*ny(i,jp1,k) + nnz*nz(i,jp1,k)
       crossy = nnz*nx(i,jp1,k) - nnx*nz(i,jp1,k)
       sfac = 0.5d0*(snew+sold(i,jp1,k))
       etmp = etmp + (1.0d0-dott*dott)-KK*dott*crossy*sfac
    endif
    ! jm1
    if (jm1 .ge. 1) then
       dott = nnx*nx(i,jm1,k) + nny*ny(i,jm1,k) + nnz*nz(i,jm1,k)
       crossy = nnz*nx(i,jm1,k) - nnx*nz(i,jm1,k)
       sfac = 0.5d0*(snew+sold(i,jm1,k))
       etmp = etmp + (1.0d0-dott*dott)+KK*dott*crossy*sfac
    endif
    
    if (kp1.le.nk) then
       dott = nnx*nx(i,j,kp1) + nny*ny(i,j,kp1) + nnz*nz(i,j,kp1)
       crossz = nnx*ny(i,j,kp1) - nny*nx(i,j,kp1)
       sfac = 0.5d0*(snew+sold(i,j,kp1))
       etmp = etmp + (1.0d0-dott*dott)-KK*dott*crossz*sfac
    endif
    if (km1.ge.1) then
       dott = nnx*nx(i,j,km1) + nny*ny(i,j,km1) + nnz*nz(i,j,km1)
       crossz = nnx*ny(i,j,km1) - nny*nx(i,j,km1)
       sfac = 0.5d0*(snew+sold(i,j,km1))
       etmp = etmp + (1.0d0-dott*dott)+KK*dott*crossz*sfac
    endif
    energy = etmp
  end function energy

  real function etot(nx,ny,nz,s,KK,ni,nj,nk)
    implicit none
    real(real64),intent(in) :: nx(:,:,:),ny(:,:,:),nz(:,:,:),KK
    integer(int64),intent(in) :: s(:,:,:),ni,nj,nk
    real(real64) :: ddot,crossx,crossy,crossz,sfac
    real(real64),allocatable::e(:,:,:)
    integer(int64) :: i,j,k,ip1,jp1,kp1
   
    allocate(e(ni,nj,nk))
    e(:,:,:) = 0.0d0
    do concurrent(i=1:ni,j=1:nj,k=1:nk)
       ip1 = mod(i,ni) + 1
       jp1 = mod(j,nj) + 1
       kp1 = k+1
       ddot = nx(i,j,k)*nx(ip1,j,k) + ny(i,j,k)*ny(ip1,j,k)+nz(i,j,k)*nz(ip1,j,k)
       crossx = ny(i,j,k)*nz(ip1,j,k)-nz(i,j,k)*ny(ip1,j,k)
       sfac = 0.5d0*(s(i,j,k)+s(ip1,j,k))
       e(i,j,k) = e(i,j,k) + (1.0d0 - ddot*ddot) - KK*ddot*crossx*sfac

       ddot = nx(i,j,k)*nx(ip1,jp1,k) + ny(i,j,k)*ny(i,jp1,k)+nz(i,j,k)*nz(i,jp1,k)
       crossy = nz(i,j,k)*nx(i,jp1,k)-nx(i,j,k)*nz(i,jp1,k)
       sfac = 0.5d0*(s(i,j,k)+s(i,jp1,k))
       e(i,j,k) = e(i,j,k) + (1.0d0 - ddot*ddot) - KK*ddot*crossy*sfac
       
       if (kp1 .le. nk) then
       ddot = nx(i,j,k)*nx(i,j,kp1) + ny(i,j,k)*ny(i,j,kp1)+nz(i,j,k)*nz(i,j,kp1)
       crossz = nx(i,j,k)*ny(i,j,kp1) - ny(i,j,k)*nx(i,j,kp1)
       sfac = 0.5d0*(s(i,j,k)+s(i,j,kp1))
       e(i,j,k) = e(i,j,k) + (1.0d0 - ddot*ddot) - KK*ddot*crossz*sfac
       endif
    enddo
    etot = sum(e)/float(ni*nj*nk)
    deallocate(e)    
  end function etot
     
end program chll
